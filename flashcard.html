<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flashcards for all</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Taviraj:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Taviraj', serif;
      line-height: 1.65;
      background: linear-gradient(135deg, #f8fafc 0%, #e0e7ef 100%);
      min-height: 100vh;
      background-image: url('https://www.transparenttextures.com/patterns/cubes.png');
    }
    h1, h2, h3 {
      font-family: 'Playfair Display', 'Taviraj', serif;
      font-weight: 700;
      line-height: 1.2;
      letter-spacing: -0.01em;
    }
    .main-card {
      background: #ffffff;
      max-width: 72rem;
      margin-left: auto;
      margin-right: auto;
      box-shadow: 0 12px 40px rgba(139,94,60,0.18), 0 2px 8px rgba(212,175,55,0.10);
      border-radius: 1.5rem;
      border: 2px solid #8B5E3C;
      padding: 2rem;
      transition: box-shadow 0.3s, transform 0.2s;
    }
    .btn-red {
      background: #8B5E3C;
      color: #fff;
      font-family: 'Taviraj', serif;
      border-radius: 9999px;
      padding: 0.75rem 2rem;
    }
    .btn-red:hover {
      background: #d4af37;
      color: #fff;
    }
    .btn-ghost {
      background: #f3f4f6;
      font-family: 'Taviraj', serif;
      border-radius: 9999px;
      padding: 0.75rem 2rem;
    }
    .card { perspective: 1000px; }
    .flip { transform-style: preserve-3d; transition: transform .35s ease; }
    .flipped { transform: rotateY(180deg); }
    .face { backface-visibility: hidden; }
    .back { transform: rotateY(180deg); }
    .no-select { user-select: none; -webkit-user-select: none; }

    /* Minimal edit UI */
    section h2 { display: none; }
    label[for], .rounded-lg.border label { display: none; }

  .icon-btn{display:inline-flex;align-items:center;gap:.25rem;padding:.25rem .5rem;border-radius:.5rem;border:1px solid #8B5E3C;background:#f5f2ed}
  .icon-btn.active{background:#d4af37;border-color:#8B5E3C}
    .hidden-card{opacity:.45;filter:grayscale(0.3)}
    .blurred{ filter: blur(6px); }
    .inverted{ transform: rotateX(180deg); }
    .ring-error{ box-shadow: 0 0 0 2px #ef4444 inset; border-color:#ef4444 }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4 text-gray-800">
  <!-- Password/authentication UI was removed. -->
  <div class="main-card w-full max-w-4xl p-6 md:p-8">
    <header class="text-center mb-6">
      <h1 class="text-3xl md:text-4xl font-extrabold text-[#8B5E3C]">Flashcards for all</h1>
      <p class="text-gray-600 mt-2 text-base md:text-lg font-medium text-center">‡∏™‡∏£‡∏∏‡∏õ‡πÉ‡∏ô‡πÅ‡∏ö‡∏ö‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏© ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏°‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÅ‡∏ö‡∏ö‡∏î‡∏¥‡∏à‡∏¥‡∏ó‡∏±‡∏•‡πÅ‡∏•‡πâ‡∏ß</p>
    </header>

    <main>
      <!-- Controls -->
      <div class="grid md:grid-cols-2 gap-4 mb-6">
        <div class="rounded-xl border p-4 bg-white/90">
          <label class="block text-sm text-gray-700 mb-1">Deck name <span class="text-red-500">*</span></label>
          <input id="deckName" type="text" class="w-full border rounded-lg px-3 py-2" placeholder="My deck" />
          <div id="deckNameError" class="text-red-600 text-sm mt-1 hidden">Deck name is required.</div>

          <div class="mt-3 flex flex-wrap gap-2">
            <button id="newCardBtn" class="btn-red rounded-lg px-4 py-2">Add card</button>
            <button id="bulkBtn" class="btn-ghost rounded-lg px-4 py-2">Bulk add</button>
            <button id="shuffleBtn" class="btn-ghost rounded-lg px-4 py-2">Shuffle</button>
            <button id="refineBtn" class="btn-ghost rounded-lg px-4 py-2">Refined by AI</button>
            <input id="pdfPicker" type="file" accept="application/pdf,image/*" multiple class="hidden" />
            <button id="genFromPdfBtn" class="btn-red rounded-lg px-4 py-2">Generate from PDF</button>
            <button id="clearBtn" class="bg-gray-200 rounded-lg px-4 py-2">Clear</button>
          </div>

          <div class="mt-3 flex flex-wrap gap-2">
            <button id="saveBtn" class="btn-ghost rounded-lg px-4 py-2">Save deck</button>
            <button id="loadBtn" class="btn-ghost rounded-lg px-4 py-2">Open</button>
            <button id="exportBtn" class="bg-gray-200 rounded-lg px-4 py-2">Download</button>
            <input id="filePicker" type="file" accept="application/json" class="hidden" />
          </div>

          <div id="ecoStats" class="mt-3 p-2 rounded text-sm hidden bg-green-100 text-green-800 border border-green-300"></div>
        </div>

        <div class="rounded-xl border p-4 bg-white/90">
          <h2 class="font-semibold">Study mode</h2>
          <div class="mt-2 flex items-center gap-2 text-sm">
            <span>Progress</span>
            <div class="flex-1 h-2 bg-gray-200 rounded">
              <div id="bar" class="h-2 bg-[#8B5E3C] rounded" style="width:0%"></div>
            </div>
            <span id="pct">0%</span>
          </div>
          <div class="mt-3 flex flex-wrap gap-2">
            <button id="studyBtn" class="btn-red rounded-lg px-4 py-2">Start</button>
            <button id="toggleHide" class="icon-btn" title="Hide/Show in study">üëÅÔ∏è Toggle</button>
            <button id="finishBtn" class="bg-gray-800 text-white rounded-lg px-4 py-2">Finish</button>
          </div>
        </div>
      </div>
      <!-- <p class="text-xs text-gray-500 text-center -mt-4 mb-4">Powered by LLMall 1</p> -->

      <!-- Editor list -->
      <section id="editorView" class="rounded-xl border p-4 bg-white/90 mb-6">
        <h2 class="font-semibold mb-2">Cards</h2>
        <div id="list" class="grid md:grid-cols-2 gap-3"></div>
      </section>

      <!-- Study view -->
      <section id="studyView" class="hidden">
        <div class="card w-full h-64 mx-auto cursor-pointer" id="flip">
          <div class="flip w-full h-full relative">
            <div class="face front absolute w-full h-full rounded-xl border-2 border-[#8B5E3C] bg-white flex items-center justify-center p-4 text-2xl text-center">
              <!-- Front content goes here -->
            </div>
            <div class="face back absolute w-full h-full rounded-xl border-2 border-gray-300 bg-white flex items-center justify-center p-4 text-2xl text-center">
              <!-- Back content goes here -->
            </div>
          </div>
        </div>
        <div id="studyControls" class="mt-4 flex justify-center gap-4 hidden">
          <button id="studyNeedWorkBtn" class="bg-red-600 text-white rounded-lg px-6 py-3 text-lg">Need Work</button>
          <button id="studyCorrectBtn" class="bg-green-600 text-white rounded-lg px-6 py-3 text-lg">Correct</button>
        </div>
      </section>

      <!-- Generation display frame (hidden until Generate is pressed) -->
      <section id="genFrame" class="hidden">
        <div class="w-full h-24 rounded-3xl border border-gray-200 bg-white/70"></div>
      </section>

    </main>

    <footer class="mt-10 text-center">
      <div class="text-[#8B5E3C] font-medium text-sm mb-1" style="font-family:'Taviraj', serif;"><b>‡∏õ‡∏±‡∏ç‡∏ç‡∏≤‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏°‡∏¥‡∏ï‡∏£‡∏ï‡πà‡∏≠‡∏™‡∏¥‡πà‡∏á‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏à‡∏£‡∏¥‡∏¢‡∏ò‡∏£‡∏£‡∏°‡∏ó‡∏≤‡∏á‡∏õ‡∏±‡∏ç‡∏ç‡∏≤‡∏õ‡∏£‡∏∞‡∏î‡∏¥‡∏©‡∏ê‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á</b></div>
      <div class="text-sm text-gray-700">‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ä‡∏±‡πâ‡∏ô ‡∏°.3/5</div>
      <div class="mt-6 text-sm text-gray-700 whitespace-pre-line text-left inline-block">
1) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏ô‡∏¥‡∏ò‡∏¥‡∏® ‡πÇ‡∏û‡∏ò‡∏¥‡πå‡∏•‡∏µ‡∏•‡∏≤‡∏ò‡∏£‡∏£‡∏° ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 6
2) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏ï‡∏¥‡∏ì‡∏ì‡πå‡∏®‡∏î‡∏¥‡∏® ‡∏ö‡∏±‡∏ì‡∏ë‡∏¥‡∏ï‡πÄ‡∏≠‡∏Å‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏• ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 13
3) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏ò‡∏µ‡∏£‡∏†‡∏±‡∏ó‡∏£‡∏™‡πå ‡∏û‡∏á‡∏©‡πå‡πÄ‡∏Å‡∏©‡∏° ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 14
4) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏û‡∏±‡∏™‡∏Å‡∏£ ‡∏ö‡∏∏‡∏ç‡∏ö‡∏π‡∏£‡∏û‡∏á‡∏Ñ‡πå ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 17
5) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡πÅ‡∏ó‡∏ô‡∏Ñ‡∏∏‡∏ì ‡πÄ‡∏ã‡∏µ‡πà‡∏¢‡∏á‡∏â‡∏¥‡∏ô ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 21
6) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏ò‡∏ô‡∏Å‡∏§‡∏ï ‡∏ö‡∏∏‡∏ç‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏ï‡∏£‡∏∞‡∏Å‡∏π‡∏• ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 26
7) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏Å‡∏£‡∏ß‡∏¥‡∏ä‡∏ç‡πå ‡πÄ‡∏û‡∏µ‡∏¢‡∏£‡∏ú‡∏•‡∏î‡∏µ‡∏™‡∏Å‡∏∏‡∏• ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 27
8) ‡πÄ‡∏î‡πá‡∏Å‡∏ä‡∏≤‡∏¢ ‡∏®‡∏∏‡∏†‡∏£‡∏∏‡∏à ‡∏®‡∏£‡∏µ‡∏´‡∏∞‡∏£‡∏±‡∏ç ‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà 39
      </div>
      <div class="text-[#8B5E3C] font-semibold text-base mt-4" style="font-family:'Taviraj', serif;">‡πÇ‡∏Ñ‡∏£‡∏á‡∏á‡∏≤‡∏ô AC Innovation ‡∏°.3</div>
      <div class="text-[#8B5E3C] font-semibold text-base mb-6" style="font-family:'Taviraj', serif;">Since 29 May 2025</div>
      <div class="flex flex-col items-center gap-3">
        <a href="index.html" class="px-4 py-2 bg-[#8B5E3C] text-white font-semibold rounded-lg shadow hover:bg-[#d4af37]" style="font-family:'Taviraj', serif;">LLM for all &gt;</a>
      </div>
    </footer>
  </div>

  <template id="rowTpl">
    <div class="rounded-lg border p-3 bg-white">
      <label class="text-xs text-gray-600">Front</label>
      <textarea class="front w-full border rounded-lg px-3 py-2 mt-1" rows="2" placeholder="Term"></textarea>
      <label class="text-xs text-gray-600 mt-2 block">Back</label>
      <textarea class="back w-full border rounded-lg px-3 py-2 mt-1" rows="2" placeholder="Definition"></textarea>
      <div class="mt-2 flex gap-2 justify-end">
        <button class="vis icon-btn" title="Toggle visibility of back">
          <span class="eye">üëÅÔ∏è</span>
        </button>
        <button class="del-btn bg-red-600 text-white rounded-lg px-3 py-1">Delete</button>
      </div>
    </div>
  </template>

  <dialog id="bulkDlg" class="rounded-xl p-0 w-full max-w-2xl">
    <div class="p-4">
      <h3 class="font-semibold text-lg">Bulk add</h3>
      <p class="text-sm text-gray-600">One card per line. Use term :: definition</p>
      <textarea id="bulkText" class="w-full border rounded-lg px-3 py-2 mt-2" rows="8" placeholder="Photosynthesis :: Plants convert light to chemical energy"></textarea>
      <div class="mt-3 flex gap-2 justify-end">
        <button id="bulkCancel" class="bg-gray-200 rounded-lg px-4 py-2">Cancel</button>
        <button id="bulkApply" class="btn-red rounded-lg px-4 py-2">Add</button>
      </div>
    </div>
  </dialog>

  <dialog id="confDlg" class="rounded-xl p-0 w-full max-w-sm">
    <div class="p-4">
      <h3 class="font-semibold text-lg">Confidence</h3>
      <p class="text-sm text-gray-600">How confident are you on this card</p>
      <input id="confRange" type="range" min="0" max="100" step="5" value="75" class="w-full mt-3">
      <div class="flex justify-between text-xs text-gray-500">
        <button data-v="0" class="quickC icon-btn">0%</button>
        <button data-v="25" class="quickC icon-btn">25%</button>
        <button data-v="50" class="quickC icon-btn">50%</button>
        <button data-v="75" class="quickC icon-btn">75%</button>
        <button data-v="100" class="quickC icon-btn">100%</button>
      </div>
      <div class="mt-4 flex gap-2 justify-end">
        <button id="confCancel" class="bg-gray-200 rounded-lg px-4 py-2">Skip</button>
        <button id="confOk" class="btn-red rounded-lg px-4 py-2">OK</button>
      </div>
    </div>
  </dialog>

  <script>
    // Password/authentication logic removed. Page loads directly into flashcard interface.
    const list = document.getElementById('list')
    const rowTpl = document.getElementById('rowTpl')
    const deckName = document.getElementById('deckName')
    const newCardBtn = document.getElementById('newCardBtn')
    const bulkBtn = document.getElementById('bulkBtn')
    const clearBtn = document.getElementById('clearBtn')
    const shuffleBtn = document.getElementById('shuffleBtn')
    const saveBtn = document.getElementById('saveBtn')
    const loadBtn = document.getElementById('loadBtn')
    const exportBtn = document.getElementById('exportBtn')
    const filePicker = document.getElementById('filePicker')

    let unsavedChanges = false;
    function markUnsaved() {
      unsavedChanges = true;
    }
    window.addEventListener('beforeunload', (e) => {
      if (unsavedChanges) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    const studyBtn = document.getElementById('studyBtn')
    const toggleHide = document.getElementById('toggleHide')
    const finishBtn = document.getElementById('finishBtn')
    const bar = document.getElementById('bar')
    const pct = document.getElementById('pct')

    const studyView = document.getElementById('studyView')
    const editorView = document.getElementById('editorView')
    const flip = document.getElementById('flip')
    const frontFace = flip.querySelector('.face.front')
    const backFace = flip.querySelector('.face.back')
    const studyNeedWorkBtn = document.getElementById('studyNeedWorkBtn')
    const studyCorrectBtn = document.getElementById('studyCorrectBtn')
    const studyControls = document.getElementById('studyControls')

    const bulkDlg = document.getElementById('bulkDlg')
    const bulkText = document.getElementById('bulkText')
    const bulkCancel = document.getElementById('bulkCancel')
    const bulkApply = document.getElementById('bulkApply')

    function ensureDeckName(){
      const name = (deckName.value || '').trim();
      const errorEl = document.getElementById('deckNameError');
      if(name){
        deckName.classList.remove('ring-error');
        if (errorEl) errorEl.classList.add('hidden');
        return name;
      }
      deckName.classList.add('ring-error');
      if (errorEl) errorEl.classList.remove('hidden');
      deckName.focus();
      return null;
    }
    deckName.addEventListener('input', ()=>{
      if((deckName.value||'').trim()) {
        deckName.classList.remove('ring-error');
        document.getElementById('deckNameError').classList.add('hidden');
      }
    })

    // AI config
    const FORCED_GEMINI_KEY = "AIzaSyAi7g9ktQXUYoj0F9j_cgTpQQhIM1CVcHQ";
    const GEMINI_MODEL = 'gemma-3-27b-it'; // gemma-3-27b-it, gemma-3-12b-it, gemma-1.5-flashcards
    const BACKEND_URL = 'https://llm-for-all-be.onrender.com';

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result).split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      })
    }

    async function callGemini(parts) {
      const payload = { contents: [{ role: 'user', parts }] };
      const url = BACKEND_URL + '/call-ai';

      async function safeFetch(url, opts, retries = 2) {
        let lastErr = null;
        for (let i = 0; i <= retries; i++) {
          try {
            const res = await fetch(url, opts);
            if (res.ok) return res;
            const body = await res.text().catch(() => '');
            throw new Error(`HTTP ${res.status} ${res.statusText} ${body.slice(0, 200)}`);
          } catch (err) {
            lastErr = err;
            await new Promise(r => setTimeout(r, 1500));
          }
        }
        throw lastErr || new Error('Network error');
      }

      const res = await safeFetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: GEMINI_MODEL, payload }),
        mode: 'cors'
      });

      const data = await res.json();
      let text = '';
      try {
        const cand = data && Array.isArray(data.candidates) ? data.candidates[0] : null;
        if (cand && cand.content && Array.isArray(cand.content.parts)) {
          text = cand.content.parts.map(p => p.text || '').filter(Boolean).join('\n');
        }
      } catch {}
      if (!text) text = JSON.stringify(data);
      return text;
    }

    // Eco stats helpers from index.html
    function estimateWater(chars) {
      const BASE_PROMPT_CHARS = 1000;
      const BASE_PROMPT_WATER_ML = 0.045; // Gemma 27B ~0.045 mL per 1000 chars
      const ml = (chars / BASE_PROMPT_CHARS) * BASE_PROMPT_WATER_ML;
      return Math.max(0.0005, ml);
    }
    function estimateEnergy(chars) {
      const BASE_PROMPT_CHARS = 1000;
      const BASE_PROMPT_ENERGY_WH = 0.045; // Gemma 27B ~0.045 Wh per 1000 chars
      const wh = (chars / BASE_PROMPT_CHARS) * BASE_PROMPT_ENERGY_WH;
      return Math.max(0.0001, wh);
    }
    function showEcoStats(charCount, cardCount) {
      const ecoStatsEl = document.getElementById('ecoStats');
      if (!ecoStatsEl) return;
      const waterMl = estimateWater(charCount);
      const energyWh = estimateEnergy(charCount);
      const co2Kg = (cardCount || 0) * 0.0025;
      ecoStatsEl.innerHTML = `Est. water: ${waterMl.toFixed(3)} ml &bull; Est. energy: ${energyWh.toFixed(3)} Wh &bull; CO2 Saved: ~${co2Kg.toFixed(4)} kg`;
      ecoStatsEl.classList.remove('hidden');
      setTimeout(() => ecoStatsEl.classList.add('hidden'), 8000);
    }

    function extractJSON(input) {
      if (input && typeof input === 'object') return input;
      let t = String(input || '').replace(/^\uFEFF/, '').replace(/```(?:json)?\s*([\s\S]*?)\s*```/gi, '$1').trim();
      try { return JSON.parse(t) } catch{}
      const first = Math.min(...[...'[{'].map(ch => t.indexOf(ch)).filter(i => i>=0));
      const last = Math.max(t.lastIndexOf('}'), t.lastIndexOf(']'));
      if (first >= 0 && last > first) {
        const s = t.slice(first, last+1).replace(/,\s*([}\]])/g, '$1');
        try { return JSON.parse(s) } catch{}
      }
      throw new Error('Could not parse JSON');
    }

    function normalizeToDeck(obj) {
      // Accept {cards:[{front,back}]}, {flashcards:[...]}, array of pairs, or array of objects
      let cards = [];
      if (Array.isArray(obj)) {
        cards = obj.map(x => Array.isArray(x) ? {front: x[0]||'', back: x[1]||''} : {front: x.front||x.term||'', back: x.back||x.definition||''});
      } else if (obj && Array.isArray(obj.cards)) {
        cards = obj.cards;
      } else if (obj && Array.isArray(obj.flashcards)) {
        cards = obj.flashcards;
      } else if (obj && Array.isArray(obj.items)) {
        cards = obj.items.map(x => ({front: x.front||x.term||'', back: x.back||x.definition||''}));
      }
      cards = cards.filter(c => c.front || c.back);
      return { name: deckName.value.trim() || 'My deck', cards };
    }

    function getDeck() {
      const cards = [...list.querySelectorAll('.rounded-lg.border')]
        .map(card => {
          const fEl = card.querySelector('textarea.front')
          const bEl = card.querySelector('textarea.back')
          const front = fEl ? String(fEl.value).trim() : ''
          const back  = bEl ? String(bEl.value).trim() : ''
          const hidden = !!card.dataset.hidden
          return { front, back, hidden }
        })
        .filter(c => c && (c.front || c.back))
      return { name: (deckName.value || 'My deck').trim(), cards }
    }
    function setDeck(deck) {
      list.innerHTML = ''
      deckName.value = deck.name || 'My deck'
      for (const c of deck.cards || []) addRow(c.front, c.back, !!c.hidden)
    }
    function addRow(front = '', back = '', hidden = false) {
      const node = rowTpl.content.cloneNode(true);
      const el = node.querySelector('.rounded-lg.border');
      const f = node.querySelector('textarea.front');
      const b = node.querySelector('textarea.back');
      f.value = front; b.value = back;
      f.addEventListener('input', markUnsaved);
      b.addEventListener('input', markUnsaved);
      const visBtn = node.querySelector('button.vis');
      function applyHidden(flag){
        if(flag){ el.classList.add('hidden-card'); el.dataset.hidden = '1' }
        else { el.classList.remove('hidden-card'); delete el.dataset.hidden }
      }
      // Eye toggles a blur effect on the back of the card
      visBtn.addEventListener('click', (e)=>{
        e.preventDefault();
        b.classList.toggle('blurred');
      });
      node.querySelector('.del-btn').addEventListener('click', () => {
        el.remove();
        markUnsaved();
      })
      list.appendChild(node)
      applyHidden(hidden)
    }

    // Buttons
    newCardBtn.addEventListener('click', () => { addRow(); markUnsaved(); })
    clearBtn.addEventListener('click', () => { list.innerHTML = ''; markUnsaved(); })
    shuffleBtn.addEventListener('click', () => {
      const deck = getDeck()
      for (let i = deck.cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        ;[deck.cards[i], deck.cards[j]] = [deck.cards[j], deck.cards[i]]
      }
      setDeck(deck);
      markUnsaved();
    })

    saveBtn.addEventListener('click', () => {
      if(!ensureDeckName()) return
      const data = getDeck()
      localStorage.setItem('flashcards_deck', JSON.stringify(data))
      saveBtn.textContent = 'Saved';
      unsavedChanges = false;
      setTimeout(() => saveBtn.textContent = 'Save deck', 900)
    })

    loadBtn.addEventListener('click', () => {
      filePicker.click();
    })

    exportBtn.addEventListener('click', () => {
      const nm = ensureDeckName(); if(!nm) return
      const blob = new Blob([JSON.stringify(getDeck(), null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url; a.download = (nm) + '.json'
      a.click(); URL.revokeObjectURL(url);
      unsavedChanges = false;
    })

    filePicker.addEventListener('change', async e => {
      const f = e.target.files[0]; if (!f) return
      const text = await f.text()
      try {
        setDeck(JSON.parse(text));
        unsavedChanges = false;
      } catch {}
      filePicker.value = ''
    })

    // Bulk add
    bulkBtn.addEventListener('click', () => { bulkText.value=''; bulkDlg.showModal() })
    bulkCancel.addEventListener('click', () => bulkDlg.close())
    bulkApply.addEventListener('click', () => {
      const lines = bulkText.value.split(/\n+/).map(s => s.trim()).filter(Boolean)
      for (const ln of lines) {
        const [a,b=''] = ln.split(/::/)
        addRow(a?.trim()||'', b?.trim()||'')
      }
      markUnsaved();
      bulkDlg.close();
    })

    // Study session
    let session = { idx: 0, seen: 0, good: 0, deck: [] }
    function updateStudyUI(){
      const total = Math.max(1, session.deck.length)
      const percent = Math.round((session.seen / total) * 100)
      bar.style.width = percent + '%'
      pct.textContent = percent + '%'
    }

    // Confidence dialog helpers
    const confDlg = document.getElementById('confDlg')
    const confRange = document.getElementById('confRange')
    const confOk = document.getElementById('confOk')
    const confCancel = document.getElementById('confCancel')
    ;[...document.querySelectorAll('.quickC')].forEach(btn=>btn.addEventListener('click',()=>{ confRange.value = btn.dataset.v }))
    function askConfidence(){
      return new Promise(resolve=>{
        confRange.value = '75'
        function done(v){ confOk.removeEventListener('click', onOk); confCancel.removeEventListener('click', onCancel); confDlg.close(); resolve(v) }
        function onOk(){ done(Number(confRange.value)) }
        function onCancel(){ done(null) }
        confOk.addEventListener('click', onOk)
        confCancel.addEventListener('click', onCancel)
        confDlg.showModal()
      })
    }

    function showCard(){
      const c = session.deck[session.idx]
      frontFace.textContent = c ? c.front : 'Front'
      backFace.textContent = c ? c.back : 'Back'
      flip.querySelector('.flip').classList.remove('flipped')
      if (studyControls) studyControls.classList.add('hidden')
      updateStudyUI()
    }

    flip.addEventListener('click', () => {
      const flipContainer = flip.querySelector('.flip')
      flipContainer.classList.toggle('flipped')
      if (studyControls) {
        const isFlipped = flipContainer.classList.contains('flipped')
        studyControls.classList.toggle('hidden', !isFlipped)
      }
    });

    studyBtn.addEventListener('click', () => {
      if(!ensureDeckName()) return
      const deck = getDeck()
      session = { idx: 0, seen: 0, good: 0, deck: deck.cards.filter(c=>!c.hidden) }
      if (session.deck.length === 0) {
        alert("No cards to study. Add cards or un-hide them first.");
        return;
      }
      editorView.classList.add('hidden');
      studyView.classList.remove('hidden');
      showCard()
    })
    function advance(){
      session.seen++
      if(session.idx < session.deck.length - 1){
        session.idx++;
        showCard();
      } else {
        alert('Finished. Score ' + Math.round((session.good/Math.max(1,session.deck.length))*100) + '%');
        updateStudyUI();
        editorView.classList.remove('hidden');
        studyView.classList.add('hidden');
      }
    }
    studyCorrectBtn.addEventListener('click', () => {
      session.good++;
      advance();
    });
    studyNeedWorkBtn.addEventListener('click', advance);
    finishBtn.addEventListener('click', ()=>{ 
      alert('Session ended. Score ' + Math.round((session.good/Math.max(1,session.deck.length))*100) + '%');
      editorView.classList.remove('hidden');
      studyView.classList.add('hidden');
    })
    toggleHide.addEventListener('click', ()=>{
      const c = session.deck[session.idx]; if(!c) return
      // find matching editor row to toggle eye there too
      const rows = [...list.querySelectorAll('.rounded-lg.border')]
      const target = rows.find(r => r.querySelector('textarea.front').value.trim()===c.front && r.querySelector('textarea.back').value.trim()===c.back)
      if(target){
        if(target.dataset.hidden){ delete target.dataset.hidden; target.classList.remove('hidden-card') }
        else { target.dataset.hidden='1'; target.classList.add('hidden-card') }
      }
    })

    // Generate from PDF or images
    const pdfPicker = document.getElementById('pdfPicker');
    const genFromPdfBtn = document.getElementById('genFromPdfBtn');
    const refineBtn = document.getElementById('refineBtn');

    genFromPdfBtn.addEventListener('click', () => {
      // Guard: ensure deck name is provided
      if (!ensureDeckName()) {
        alert("Please enter a deck name before generating flashcards.");
        return;
      }
      const frame = document.getElementById('genFrame');
      if(frame) frame.classList.remove('hidden');
      pdfPicker.click();
    });

    pdfPicker.addEventListener('change', async (e) => {
      const files = [...e.target.files];
      if (!files.length) return;
      // File size guardrail: max 20MB per file
      const MAX_SIZE = 20 * 1024 * 1024;
      const validFiles = [];
      for (const f of files) {
        if (f.size > MAX_SIZE) {
          alert("File too large (max 20 MB): " + f.name);
        } else {
          validFiles.push(f);
        }
      }
      if (!validFiles.length) {
        pdfPicker.value = ''; // reset file picker if all files invalid
        return;
      }
      if (!ensureDeckName()) {
        pdfPicker.value = ''; // Clear file picker if name is missing
        return;
      }
      const originalText = genFromPdfBtn.textContent;
      genFromPdfBtn.disabled = true;
      genFromPdfBtn.textContent = 'Generating...';
      genFromPdfBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
      genFromPdfBtn.classList.remove('btn-red');
      try {
        // Build parts with a guiding prompt
        const parts = [
          { text: 'Create concise flashcards from the attached files. Output JSON with an array named cards, where each item is {"front":"term","back":"definition"}. Keep 20 to 60 cards. Concise wording.' }
        ];
        for (const f of validFiles) {
          const b64 = await fileToBase64(f);
          parts.push({ inline_data: { mime_type: f.type || 'application/pdf', data: b64 } });
        }
        const raw = await callGemini(parts);
        const data = extractJSON(raw);
        const deck = normalizeToDeck(data);
        markUnsaved();
        setDeck(deck);
        const charCount = JSON.stringify(deck).length;
        const cardCount = deck.cards ? deck.cards.length : 0;
        showEcoStats(charCount, cardCount);
      } catch (err) {
        alert('AI failed to create flashcards. ' + (err && err.message ? err.message : ''));
      } finally {
        pdfPicker.value = '';
        genFromPdfBtn.disabled = false;
        genFromPdfBtn.textContent = originalText;
        genFromPdfBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
        genFromPdfBtn.classList.add('btn-red');
      }
    });

    // Refined by AI: improve current deck
    refineBtn.addEventListener('click', async () => {
      if(!ensureDeckName()) return
      const deck = getDeck();
      if (!deck.cards.length) { alert('No cards to refine'); return; }
      const originalText = refineBtn.textContent;
      refineBtn.disabled = true;
      refineBtn.textContent = 'Generating...';
      refineBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
      refineBtn.classList.remove('btn-ghost');
      try {
        const parts = [
          { text: 'Refine this flashcard deck. Improve clarity, remove duplicates, merge near-duplicates, and keep 20 to 60 strong cards. Return JSON {"cards":[{"front":"term","back":"definition"}]} strictly.' },
          { text: JSON.stringify(deck) }
        ];
        const raw = await callGemini(parts);
        const data = extractJSON(raw);
        const refined = normalizeToDeck(data);
        markUnsaved();
        setDeck(refined);
        const charCount = JSON.stringify(refined).length;
        const cardCount = refined.cards ? refined.cards.length : 0;
        showEcoStats(charCount, cardCount);
      } catch (err) {
        alert('AI refinement failed. ' + (err && err.message ? err.message : ''));
      } finally {
        refineBtn.disabled = false;
        refineBtn.textContent = originalText;
        refineBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
        refineBtn.classList.add('btn-ghost');
      }
    });

    // Load previous deck if present
    (()=>{ const raw = localStorage.getItem('flashcards_deck'); if(raw){ try{ setDeck(JSON.parse(raw)); unsavedChanges = false; }catch{} } })()
  </script>

</body>
</html>